# This scripts translates the defined communication interfaces to C++ code.
# The generated structs should be used for reading and writing data.
# JsonDocument instances from the ArduinoJson library may only be used for deserialization and serialization.

Set-Location $PSScriptRoot

Write-Output "Running C++ interface code generation ..."

$JSON_MEMBER_SIZE = 8  # Size in bytes that is needed by a single member in a json object on an AVR microchip architecture as used in Arduino MEGA
function CalculateJsonDocSize($interfaceDef)
{
    $size = 0
    foreach ($prop in $interfaceDef.psobject.Properties)
    {
        if ($prop.Value.GetType().Name -eq "String")
        {
            $size += $JSON_MEMBER_SIZE
        }
        elseif ($prop.Value.GetType().Name -eq "PSCustomObject")
        {
            $size += $JSON_MEMBER_SIZE + $( CalculateJsonDocSize $prop.Value )
        }
    }
    return $size
}
function CreateInterfaceStruct($interfaceDef)
{
    $string = ""
    foreach ($prop in $interfaceDef.psobject.Properties)
    {
        if ($prop.Value.GetType().Name -eq "String")
        {
            if ($prop.Value -match "\[(\d+)\]") {
                # Type is an array
                $size = [int]$Matches[1]
                $type = ($prop.Value -split "\[")[0]
                $string += "$type $( $prop.Name )[$size];"
            }
#            if ($prop.Value -match "(?i)char|String") {
#                $string += "String $( $prop.Name );"  # Only use String
#            }
            else {
                $string += "$( $prop.Value ) $( $prop.Name );"
            }
        }
        elseif ($prop.Value.GetType().Name -eq "PSCustomObject")
        {
            $string += "struct {`n$( CreateInterfaceStruct $prop.Value )} $( $prop.Name );"
        }
        $string += "`n"
    }
    return $string
}
function CreateInterfaceStructFromDoc($interfaceDef)
{
    function AssignStructMember($val, $accessor)
    {
        $string = ""
        if ($val.GetType().Name -eq "String")
        {
            if ($val -match "\[(\d+)\]") {
                # char arrays must be assigned using strlcpy
                $size = [int]$Matches[1]
                $string += "strlcpy(this->$accessor, doc[`"$( $accessor.Replace('.', '`"][`"') )`"] | `"`", $size);`n"
            }
            else {
                $string = "this->$accessor = doc[`"$( $accessor.Replace('.', '`"][`"') )`"];`n"
            }
        }
        elseif ($val.GetType().Name -eq "PSCustomObject")
        {
            foreach ($prop in $val.psobject.Properties)
            {
                $string += AssignStructMember $prop.Value "$accessor.$( $prop.Name )"
            }
        }
        return $string
    }
    $string = ""
    foreach ($prop in $interfaceDef.psobject.Properties)
    {
        $string += AssignStructMember $prop.Value $prop.Name
    }
    return $string
}
function CreateInterfaceStructToDoc($interfaceDef)
{
    function AssignDocMember($val, $objName, $accessor)
    {
        $key = $accessor.Split(".")[-1]
        $string = ""
        if ($val.GetType().Name -eq "String")
        {
            $string = "$objName[`"$key`"] = this->$accessor;`n"
        }
        elseif ($val.GetType().Name -eq "PSCustomObject")
        {
            $string = "JsonObject $key = $objName.createNestedObject(`"$key`");`n"
            foreach ($prop in $val.psobject.Properties)
            {
                $string += AssignDocMember $prop.Value $key "$accessor.$( $prop.Name )"
            }
        }
        return $string
    }
    $string = ""
    foreach ($prop in $interfaceDef.psobject.Properties)
    {
        $string += AssignDocMember $prop.Value doc $prop.Name
    }
    return $string
}

$interfaceJsonContentString = Get-Content -Path "..\..\..\interface.json"
$interfaceJsonObject = $interfaceJsonContentString | ConvertFrom-Json

$fileString = "// This file is automatically generated

#ifndef INTERFACE_HPP
#define INTERFACE_HPP

#include <ArduinoJson.h>

#define JSON_DOC_SIZE_RX $( CalculateJsonDocSize $interfaceJsonObject.to_device )
#define JSON_DOC_SIZE_TX $( CalculateJsonDocSize $interfaceJsonObject.from_device )

namespace ComInterface {
struct RX {

$( CreateInterfaceStruct $interfaceJsonObject.to_device )
void from_doc(StaticJsonDocument<JSON_DOC_SIZE_RX> &doc) {
$( CreateInterfaceStructFromDoc $interfaceJsonObject.to_device )}
bool receive();
};

struct TX {
$( CreateInterfaceStruct $interfaceJsonObject.from_device )
void to_doc(StaticJsonDocument<JSON_DOC_SIZE_TX> &doc) {
$( CreateInterfaceStructToDoc $interfaceJsonObject.from_device )}
bool transmit();
};
}

#endif
"

Set-Content -NoNewline -Path "interface.hpp" -Value $fileString

Write-Output "C++ interface code generation finished!"
